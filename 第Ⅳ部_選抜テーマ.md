# 第Ⅳ部/ 選抜テーマ

- 効果的で読みやすいテストの書き方について

- 特定用途のデータ構造(「分/時間カウンタ」)の設計と実装



## テストと読みやすさ

すっきりと効果的なテストを書くための簡単な技法について。

### テストを読みやすくして保守しやすいものにする

**カギとなる考え**

> 他のプログラマが安心してテストの追加や変更ができるように、テストコードを読みやすくする

テストコードが大きく恐ろしいものである場合、以下のことが起こりうる。

- 本物のコードを修正するのを恐れる
- 新しいコードを書いたときにテストを追加しなくなる

コードのユーザにはテストコードを安心して使ってもらいたい。テストコードを変更したことで既存のテストが壊れても簡単に原因を突き止められるようにしておきたい。

### テストを読みやすくする

一般的な設計原則として、**「大切ではない詳細はユーザから隠し、大切な詳細は目立つようにする」**べき。

#### 最小のテストを作る

このテストが何をしようとしているのかを簡単な言葉で説明する。テストの本質というのは、「こういう状況と入力から、こういう振る舞いと出力を期待する」を表すもの。これは1行でまとめられることが多い。

コードを簡潔に読みやすくするだけでなく、テストステートメントを短くすることで、テストケースの追加が簡単になる。

#### 独自の「ミニ言語」を実装する

独自のミニ言語を定義すれば、小さな領域で多くの情報を表現できる。`printf`や正規表現ライブラリなども、文字列で別の意味を表現できるようになる。

### エラーメッセージを読みやすくする

#### もっといいassert()を使う

Pythonの場合、`assert a == b`では以下のようなエラーメッセージが表示される。

```
File "file.py", line X, in <module>
	assert a == b
AssertionError
```

代わりに、`unittest`モジュールの`assertEqual()`メソッドが使える。

```python
import unittest

class MyTestcase(unittest.TestCase):
	def testFunc(self):
		a = 1
		b = 2
		self.assertEqual(a,b)
if __name__ == "__main__":
	unittest.main()
```

これは以下のエラーメッセージを表示する

```
File "MyTestCase.py", line 7, in testFunc
	self.assertEqual(a,b)
AssertionError: 1 != 2
```

どの言語においても役立つライブラリやフレームワークがきっとあるはず。



#### 手作りのエラーメッセージ

自分の欲しいメッセージが欲しい場合は自分で書けばよい！その際、「エラーメッセージはできるだけ役に立つ」ように心がける。



### テストの適切な入力値を選択する

適切な入力値というのは、コードを完全にテストするものでなければいけない。

**カギとなる考え**

> コードを完全にテストする最も単純な入力値の組み合わせを選択しなければいけない

#### 入力値を単純化する

テストの効果を変えずにできるだけ単純な値を選ぶ

**カギとなる考え**

> テストには最もキレイで単純な値を選ぶ

#### 1つの機能に複数のテスト

コードを検証する「完璧」な入力値を1作るのではなく、小さなテストを複数作る方が、簡単で、効果的で、読みやすい。

```c++
CheckScoresBeforeAfter("2, 1, 3", "3, 2, 1");    // ソート
CheckScoresBeforeAfter("0, -0.1, -10", "0");     // マイナスは削除
CheckScoresBeforeAfter("1, -2, 1, -2", "1, 1");  // 重複は許可
CheckScoresBeforeAfter("", "");                  // 空の入力は許可
```

失敗したテストによってその場所もわかる。



### テストの機能に名前をつける

テストコードは関数になっていることが多い。関数はテストするメソッドや状況でひとまとめにする。

`Test1()`や`Test2()`など無意味な名前は避ける。以下のことを一目で理解できる名前を付けるべき。

- テストするクラス(あれば)
- テストする関数
- テストする状況やバグ

`Test_<関数名>_<状況>()`という形式が望ましい。ほかのコードから呼び出されるものではないので、長くなってもかまわない。テストの関数名はコメントだと思えばよい。テストが失敗したらその関数名が印字されることが多いため、名前はむしろ説明的な方が役に立つ。

### テストに優しい開発

テスト容易性の低いコードの特性とそこから生じる設計の問題

| 特性                                   | テスト容易性の問題                                           | 設計の問題                                                   |
| -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| グローバル変数を使っている             | グローバルの状態をテストごとに初期化する必要がある           | ・どの関数にどんな副作用があるのかわかりにくい。<br />・関数を個別に考えることができない。<br />・すべてを理解するにはプログラム全体を把握しなければならない。 |
| 多くの外部コンポーネントに依存している | 最初に足場を設定しなければいけないので、テストを書くのが難しい。そのためみんなテストを書こうとしなくなる | ・依存しているものが落ちるとシステムが使えなくなる。<br />・任意の変更にどんな影響があるのか理解困難。<br />・クラスのリファクタリングが困難。<br />・考えなければいけない故障状態や回復経路が増える |
| コードが非決定的な動作をする           | テストは当てにならず、信頼できない。最終的には無視されるようになる | ・プログラムが競合状態になったり、再現不可能なバグが発生しうる。<br />・プログラムを論理的に判断できなくなる。<br />・バグの追跡や修正が非常に困難。 |



テスト容易性の高いコードの特性とそこから生じる設計の利点

| 特性                                                         | テスト容易性の利点                                           | 設計の利点                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| クラスが小さい。あるいは内部状態を持たない                   | ・テストがしやすい。・<br />メリットをテストするのにセットアップがあまり必要にならない。<br />・検査する状態が隠されていない。 | ・状態の少ないクラスは単純で理解しやすい。                   |
| クラスや関数が一つのことをしている                           | ・完全にテストをするためのテストケースが少なくて済む。       | ・小さくても単純なコンポーネントがモジュール化されている<br />・システムは疎結合である |
| クラスは他のクラスにあまり依存していない。高度に疎結合化されている | ・各クラスは独立してテストできる                             | ・システムを並列に開発できる<br />・クラスは他の部分を気にすることなく簡単に修正や削除できる |
| 関数は単純でインターフェースが明確である                     | ・明確な動作をテストできる<br />・単純なインターフェースなのでテストが楽 | ・インターフェースがわかりやすくて再利用しやすい             |

### やりすぎ

場合によってはテストに集中しすぎてしまう可能性もある

- テストのために本物のコードの読みやすさを犠牲にしてしまう。

  本物のコードをテストしやすいように設計するには、両者に利点がなければいけない。本物のコードは単純にする。テストは読み書きしやすくする。テストをしやすくするためだけに本物のコードにゴミを入れてはいけない。

- テストのカバレッジを100%にしないと気が済まない。

  コードの90%をテストする方が、残り10%をテストするよりも楽。最後の10%にはUIのどうでもいいエラーケースが含まれている。その部分はバグの修正コストが高くないのでテストが割に合わない。現実的にはカバレッジが100%になることはない。もしもなっているとしたら、バグの見落とし or 機能が実装されていない or 仕様が変更されたことに気づいていない、のどれかを疑う。
  バグのコストによって、テストコードにかける最適な時間は違ってくるので、かける時間の見極めも重要。

- テストがプロダクト開発の邪魔になる

  プロジェクトの一部に過ぎないテストが、プロジェクト全体を支配していては意味がない。


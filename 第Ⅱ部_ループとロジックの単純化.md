# 第Ⅱ部 / ループとロジックの単純化

コードを動かすための制御フロー、論理式、変数の部分の改善。

## 制御フローを読みやすくする

**カギとなる考え：**

> 条件やループなどの制御フローはできるだけ「自然」にする。コードの読み手が立ち止まったり読み返したりしないように書く。

### 条件式の引数の並び順

```python
if X > Y:
```

引数の順番の原則：

| 左側                         | 右側                                 |
| ---------------------------- | ------------------------------------ |
| 「調査対象」の式。変化する。 | 「比較対象」の式。あまり変化しない。 |

自然言語の感覚と同じ。「もしLLLがRRRならば」というように先に調査対象(LLL)、後に比較対象(RRR)というのが自然。



### if/elseブロックの並び順

- 条件は否定形よりも肯定形を使う。例えば、`if (!debug)`ではなく、`if (debug)`を使う。
- 単純な条件を先に書く。`if`と`else`が同じ画面に表示されるので見やすい。
- 関心を引く条件や目立つ条件を先に書く

この優劣は衝突することもあるので、その時は自分で判断が必要。だが、優先度は明確に決まることが多い。

```python
if not file:
	# エラーをログに記録する
else:
	# ・・・
```

関心や注意を引く処理を先に処理する。



### 三項演算子

**アドバイス：**

> 基本的には`if/else`を使おう。三項演算子はそれによって簡潔になる時にだけ使おう

- 良い例：三項演算子を使った方がシンプルになる

  ```c++
  // 三項演算子あり
  time_str += (hour >= 12) ? "pm" : "am";
  
  // 三項演算子なし
  if (hour >= 12) {
  	time_str += "pm";
  } else {
  	time_str += "am";
  }
  ```

- 悪い例： 三項演算子を使わずに書いた方が分かりやすい

  ```c++
  // 三項演算子あり
  return exponent >= 0 ? mantissa * (1 << exponent) : mantissa / (1 << -exponent);
  
  // 三項演算子なし
  if (exponent >= 0) {
  	return mantissa * (1 << exponent);
  } else {
  	return mantissa / (1 << -exponent);
  }
  ```

### do/whileループを避ける

do/whileループは、コードブロックを再実行する条件が下にある。一方、if,while, for文などの条件はコードブロックの上にある。コードは上から下に呼んでいくので、do/whileは少し不自然。コードを二回読む必要がある。

do/whileループはwhileループで書きなおす方がベター。



### 関数から早く返す

返り値をこまめに早く返すことはいいこと。関数内でreturn文を複数使うという選択肢も頭の片隅に置いておこう。



### ネストを浅くする

ネストが深くなると、読み手は「精神的スタック」に条件をプッシュしなければいけない。閉じ括弧を見てスタックからポップしようと思っても、その条件が何だったのかを確認しなおさなければならなくなる。

#### ネストが増える仕組み

**カギとなる考え：**

> 変更するときにはコードを新鮮な目で見る。一歩下がって全体を見る。

#### 早めに返してネストを削除する

ネストを削除するには「失敗ケース」をできるだけ早めに関数から返せばよい。

```c++
if (user_result != SUCCESS) {
	・・・
	return;
}

if (permission_result != SUCESS) {
	・・・
	return;
}

・・・
reply.Done();
```

全てのifブロックをreturnで終了することで、精神的なスタックは「ポップ」する必要がなくなる。



#### ループ内部のネストを削除する

早めに返す技法はいつでも使えるわけではない。returnできないときはcontinueを使うとよい。ただし、continueはコードを行ったり来たりするためわかりにくくなることが多いことに留意。



### 実行の流れを追えるかい？

プログラムの高レベルの「流れ」について、できればプログラムのすべての実行パスを簡単に追えるようになれるのがベスト。main()から出発し、心の中でコードを追っていく。関数を次々に呼び出していく。それをプログラムが終了するまで。

- コードの「舞台裏」で実行する構成要素の例

  - スレッド
  - シグナル/割り込みハンドラ
  - 例外
  - 関数ポインタと無名関数
  - 仮想メソッド

  これらの要素を使うことでコードが読みやすくなったり冗長性が低くなることもある。でも、あとで理解しにくくなることを考えずに使いすぎてしまうとバグを見つけるのが難しくなる。そのため、コード全体に占める割合を増やさないことが大切。



## 巨大な式を分割する

**カギとなる考え：**

> 巨大な式は飲み込みやすい大きさに分割する

### 説明変数

式を簡単に分割するには「説明変数」を使えばよい。

```python
if line.split(':')[0].strip() == "root":
	・・・

# 説明変数
username = line.split(':')[0].strip()
if username == "root":
```

説明変数のメリット

- 巨大な式を分割できる
- 簡潔な名前で式を説明することで、コードを文書化できる
- コードの主要な「概念」を読み手が認識しやすくなる



### 要約変数

式を説明する必要がない場合でも、式を変数に代入しておくと便利。大きなコードの塊を小さな名前に置き換えて、管理や把握を簡単にする変数のことをようやく変数と呼ぶ。

```c++
if (request.user.id == document.owner_id) {
	// ユーザはこの文章を編集可能
}
```

要約変数を使うと、

```c++
final boolean user_owns_document = (request.user.id == document.owner_id);

if (user_own_document) {
	// ユーザはこの文章を編集可能
}
```

最上部に要約変数を定義することで、シンプルになるだけでなく、「この関数で参照する概念」を事前に伝えることができる。



### ド・モルガンの法則を使う

論理式を等価な式に置き換える方法は２つ

- `not (a or b or c) == (not a) and (not b) and (not c)`
- `not (a and b and c) == (not a) or (not b) or (not c)`

この法則を使えば論理式を読みやすくできる。

```c++
if (!(file_exists && !is_protected)) Error("Sorry, could not read file.")

if (!file_exitsts || is_protected) Error("Sorry, could not read file.") ## ド・モルガンによる書き直し
```





### 短絡評価の悪用

**カギとなる考え**

> 「頭がいい」コードに気を付ける。あとで他の人がコードを読むときにわかりにくくなる。

- 良い短絡評価の使い方

  ```c++
  if (object && object->method()) ・・・
  ```

- 悪い短絡評価の使い方

  ```java
  assert((!(bucket = FindBucket(key))) || !bucket->IsOccupied());
  ```

  「このキーのバケツを取得する。もしバケツがnullでなければ、中身が入っていないか確認する」を一行で表しているがしばらく立ち止まって考えないとわかりにくい。この場合、2行になるが下の方に書きなおす方が好ましい。

  ```java
  bucket = FindBucket(key);
  if (bucket != NULL) assert(!bucket->IsOccupied());
  ```



## 変数と読みやすさ

変数を適当に使った場合にぶち当たる問題

- 変数が多いと変数を追跡するのが難しくなる
- 変数のスコープが大きいとスコープを把握する時間が長くなる
- 変数が頻繁に変更されると現在の値を把握するのが難しくなる

これらの問題にどう対処すればいいか。

### 変数を削除する

コードが読みやすくならない変数を削除する。

#### 一時変数

```python
now = datetime.datetime.now()
root_message.last_view_time = now
```

この`now`を使う意味はない。意味がない理由は以下3点

- 複雑な式を分割していない
- より明確になっていない
- 一度しか使っていないので、重複コードの削除に貢献していない

#### 中間結果

```python
def extract_pos_word(input_word):
	middle_result = func1(input_word)
	result = func2(middle_result)
	
def extract_pos_word(input_word):
	result = func2(func1(input_word))
```

中間結果は使わずに結果をそのまま使えば削減できる。

#### 制御フロー変数を削除する

```c++
boolean done = false;
while (/*条件*/ && !done) {
	・・・
	if (...) {
		done = true;
		continue;
	}
}
```

`done`のような変数を「制御フロー変数」と呼ぶ。プログラムの実行を制御するためだけの変数であり、実際のプログラムに関係あるデータは含まれていない。これは以下のように削除できる。

```c++
while (/*条件*/) {
	...
	if (...) {
		break;
	}
}
```

breakできないような複数段階のネストループのときはコードを新しい関数に移動するとよい。

### 変数のスコープを縮める

「グローバル変数は避ける」ということは非常に良いこと。グローバル変数はどこでどのように使われているのかを追跡するのが難しい。また、「名前空間を汚染する」ことからローカル変数を使っているつもりでグローバル変数を修正したり、その逆が起こったりしてしまう可能性もある。

グローバル変数に限らず、**すべての**変数の「スコープを縮める」のはいいこと。

**カギとなる考え**

> 変数のことが見えるコード行数をできるだけ減らす

クラスのメンバへのアクセスを制限する方法

- ミニグローバルとなっている変数をローカル変数に「格下げ」する
- メソッドをできるだけstaticにする
- 大きなクラスを小さなクラスに分割する



Tips:

- JavaScriptの「ベストプラクティス」は「変数を定義するときには常に`var`(または`let`,`const`)をつける」。

  こうすることで変数のスコープをその変数が定義された(もっとも内側の)関数に制限してくれる。

- python, JavaScriptでは、ブロックで定義された変数はその関数全体に「こぼれ出る」。変数を使っている場所の「最も近い共通の祖先(ネスト的な意味で)」で変数を定義することで「こぼれ出る」ことで発生しうるエラーを防ぐことができる。

- 変数の定義は変数を使う直前にすればよい。

### 変数は一度だけ書き込む

変数が絶えず変更され続けると値を追跡する難易度が格段に上がってしまう。これを避けるためには**変数は一度だけ書き込む**ようにするとよい。

**カギとなる考え**

> 変数を操作する場所が増えると、現在地の判断が難しくなる。



